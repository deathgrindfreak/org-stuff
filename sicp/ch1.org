* 1 Building Abstractions with Procedures
** 1.1  The Elements of Programming
*** 1.1.6  Conditional Expressions and Predicates
**** Exercise 1.1
And so it begins, the first exercise of SICP.  The expressions shown
return the following:

#+BEGIN_SRC scheme
10 => 10

(+ 5 3 4) => 12

(- 9 1) => 8

(/ 6 2) => 3

(+ (* 2 4) (- 4 6)) => 6

(define a 3) => <void>

(define b (+ a 1)) => <void>

(+ a b (* a b)) => 19

(= a b) => #f

(if (and (> b a) (< b (* a b)))
    b
    a) => 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) => 16
(+ 2 (if (> b a) b a)) => 6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) => 16
#+END_SRC
**** Exercise 1.2
     The lisp form of the expression:

     <NEED_TO_CONVERT_USING_MATHJAX>
     
     is

     #+BEGIN_SRC scheme
(/ (+ 5 4 (- 2 3 (+ 6 (/ 4 5))))
   (* 3 (- 6 2) (- 2 7)))
     #+END_SRC
**** Exercise 1.3
     In terms of the functions and special forms we've covered thus
     far we have:
     
    #+BEGIN_SRC scheme
(define (square-sum-of-max-of-two a b c)
  (cond ((or (> a b c)
             (> b a c)) (+ (* a a)
                           (* b b)))
        ((or (> a c b)
             (> c a b)) (+ (* a a)
                           (* c c)))
        ((or (> b c a)
             (> c b a)) (+ (* b b)
                           (* c c)))))
    #+END_SRC
**** Exercise 1.4
     This is the first occurence of what is called a "higher-order"
     function, which is simply a function that can take other
     functions as arguments or in turn, return them.  
     
     Thus in this case the 'if' special-form returns the '+' or '-'
     function based on the value of b.
**** Exercise 1.5
     If his interpreter uses normal order evaluation, then test
     will return with a value of 0, since it will expand like so:

     #+BEGIN_SRC scheme
(test 0 (p)) => (if (= x 0) => 0
                    0
                    (p))
     #+END_SRC
     
     However, applicative order evaluation would result in an infinite
     loop, since before the body of test was ever evaluated, (p) in
     the second argument would be evaluated first.
*** 1.1.7  Example: Square Roots by Newton's Method
**** Exercise 1.6
     Since the interpreter uses applicative order evaluation, the
     else-expression in new-if will be evaluated when the function is
     called. And since the else expression is a recursive call to
     sqrt-iter, the base case will never be reached and an infinite
     loop will occur.
**** Exercise 1.7
     
*** 1.1.8  Procedures as Black-Box Abstractions
** 1.2  Procedures and the Processes They Generate
*** 1.2.1  Linear Recursion and Iteration
*** 1.2.2  Tree Recursion
*** 1.2.3  Orders of Growth
*** 1.2.4  Exponentiation
*** 1.2.5  Greatest Common Divisors
*** 1.2.6  Example: Testing for Primality
** 1.3  Formulating Abstractions with Higher-Order Procedures
*** 1.3.1  Procedures as Arguments
*** 1.3.2  Constructing Procedures Using Lambda
*** 1.3.3  Procedures as General Methods
*** 1.3.4  Procedures as Returned Values
